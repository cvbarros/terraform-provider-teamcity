// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	strfmt "github.com/go-openapi/strfmt"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/swag"
)

// Build build
// swagger:model build
type Build struct {

	// agent
	Agent *Agent `json:"agent,omitempty"`

	// artifact dependencies
	ArtifactDependencies *Builds `json:"artifact-dependencies,omitempty"`

	// artifacts
	Artifacts *Files `json:"artifacts,omitempty"`

	// attributes
	Attributes *Entries `json:"attributes,omitempty"`

	// branch name
	BranchName string `json:"branchName,omitempty" xml:"branchName"`

	// build type
	BuildType *BuildType `json:"buildType,omitempty"`

	// build type Id
	BuildTypeID string `json:"buildTypeId,omitempty" xml:"buildTypeId"`

	// build type internal Id
	BuildTypeInternalID string `json:"buildTypeInternalId,omitempty" xml:"buildTypeInternalId"`

	// canceled info
	CanceledInfo *Comment `json:"canceledInfo,omitempty"`

	// chain modification Id
	ChainModificationID string `json:"chainModificationId,omitempty"`

	// changes
	Changes *Changes `json:"changes,omitempty"`

	// comment
	Comment *Comment `json:"comment,omitempty"`

	// compatible agents
	CompatibleAgents *Agents `json:"compatibleAgents,omitempty"`

	// composite
	Composite *bool `json:"composite,omitempty" xml:"composite"`

	// current settings hash
	CurrentSettingsHash string `json:"currentSettingsHash,omitempty"`

	// custom artifact dependencies
	CustomArtifactDependencies *ArtifactDependencies `json:"custom-artifact-dependencies,omitempty"`

	// default branch
	DefaultBranch *bool `json:"defaultBranch,omitempty" xml:"defaultBranch"`

	// failed to start
	FailedToStart *bool `json:"failedToStart,omitempty" xml:"failedToStart"`

	// finish date
	FinishDate string `json:"finishDate,omitempty"`

	// history
	History *bool `json:"history,omitempty" xml:"history"`

	// href
	Href string `json:"href,omitempty" xml:"href"`

	// id
	ID int64 `json:"id,omitempty" xml:"id"`

	// last changes
	LastChanges *Changes `json:"lastChanges,omitempty"`

	// links
	Links *Links `json:"links,omitempty"`

	// locator
	Locator string `json:"locator,omitempty" xml:"locator"`

	// metadata
	Metadata *Datas `json:"metadata,omitempty"`

	// modification Id
	ModificationID string `json:"modificationId,omitempty"`

	// number
	Number string `json:"number,omitempty" xml:"number"`

	// percentage complete
	PercentageComplete int32 `json:"percentageComplete,omitempty" xml:"percentageComplete"`

	// personal
	Personal *bool `json:"personal,omitempty" xml:"personal"`

	// pin info
	PinInfo *Comment `json:"pinInfo,omitempty"`

	// pinned
	Pinned *bool `json:"pinned,omitempty" xml:"pinned"`

	// problem occurrences
	ProblemOccurrences *ProblemOccurrences `json:"problemOccurrences,omitempty"`

	// properties
	Properties *Properties `json:"properties,omitempty"`

	// queued date
	QueuedDate string `json:"queuedDate,omitempty"`

	// related
	Related *Related `json:"related,omitempty"`

	// related issues
	RelatedIssues *IssuesUsages `json:"relatedIssues,omitempty"`

	// replacement ids
	ReplacementIds *Items `json:"replacementIds,omitempty"`

	// resulting properties
	ResultingProperties *Properties `json:"resultingProperties,omitempty"`

	// revisions
	Revisions *Revisions `json:"revisions,omitempty"`

	// running
	Running *bool `json:"running,omitempty" xml:"running"`

	// running info
	RunningInfo *ProgressInfo `json:"running-info,omitempty"`

	// settings hash
	SettingsHash string `json:"settingsHash,omitempty"`

	// snapshot dependencies
	SnapshotDependencies *Builds `json:"snapshot-dependencies,omitempty"`

	// start date
	StartDate string `json:"startDate,omitempty"`

	// start estimate
	StartEstimate string `json:"startEstimate,omitempty"`

	// state
	State string `json:"state,omitempty" xml:"state"`

	// statistics
	Statistics *Properties `json:"statistics,omitempty"`

	// status
	Status string `json:"status,omitempty" xml:"status"`

	// status text
	StatusText string `json:"statusText,omitempty"`

	// tags
	Tags *Tags `json:"tags,omitempty"`

	// task Id
	TaskID int64 `json:"taskId,omitempty" xml:"taskId"`

	// triggered
	Triggered *TriggeredBy `json:"triggered,omitempty"`

	// triggering options
	TriggeringOptions *BuildTriggeringOptions `json:"triggeringOptions,omitempty"`

	// unspecified branch
	UnspecifiedBranch *bool `json:"unspecifiedBranch,omitempty" xml:"unspecifiedBranch"`

	// used by other builds
	UsedByOtherBuilds *bool `json:"usedByOtherBuilds,omitempty" xml:"usedByOtherBuilds"`

	// user
	User *User `json:"user,omitempty"`

	// versioned settings revision
	VersionedSettingsRevision *Revision `json:"versionedSettingsRevision,omitempty"`

	// wait reason
	WaitReason string `json:"waitReason,omitempty"`

	// web Url
	WebURL string `json:"webUrl,omitempty" xml:"webUrl"`
}

// Validate validates this build
func (m *Build) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAgent(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateArtifactDependencies(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateArtifacts(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateAttributes(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateBuildType(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCanceledInfo(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateChanges(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateComment(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCompatibleAgents(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateCustomArtifactDependencies(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLastChanges(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateLinks(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateMetadata(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validatePinInfo(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateProblemOccurrences(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateProperties(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateRelated(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateRelatedIssues(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateReplacementIds(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateResultingProperties(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateRevisions(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateRunningInfo(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateSnapshotDependencies(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateStatistics(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTags(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTriggered(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateTriggeringOptions(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateUser(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if err := m.validateVersionedSettingsRevision(formats); err != nil {
		// prop
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Build) validateAgent(formats strfmt.Registry) error {

	if swag.IsZero(m.Agent) { // not required
		return nil
	}

	if m.Agent != nil {

		if err := m.Agent.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("agent")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateArtifactDependencies(formats strfmt.Registry) error {

	if swag.IsZero(m.ArtifactDependencies) { // not required
		return nil
	}

	if m.ArtifactDependencies != nil {

		if err := m.ArtifactDependencies.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("artifact-dependencies")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateArtifacts(formats strfmt.Registry) error {

	if swag.IsZero(m.Artifacts) { // not required
		return nil
	}

	if m.Artifacts != nil {

		if err := m.Artifacts.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("artifacts")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateAttributes(formats strfmt.Registry) error {

	if swag.IsZero(m.Attributes) { // not required
		return nil
	}

	if m.Attributes != nil {

		if err := m.Attributes.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("attributes")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateBuildType(formats strfmt.Registry) error {

	if swag.IsZero(m.BuildType) { // not required
		return nil
	}

	if m.BuildType != nil {

		if err := m.BuildType.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("buildType")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateCanceledInfo(formats strfmt.Registry) error {

	if swag.IsZero(m.CanceledInfo) { // not required
		return nil
	}

	if m.CanceledInfo != nil {

		if err := m.CanceledInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("canceledInfo")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateChanges(formats strfmt.Registry) error {

	if swag.IsZero(m.Changes) { // not required
		return nil
	}

	if m.Changes != nil {

		if err := m.Changes.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("changes")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateComment(formats strfmt.Registry) error {

	if swag.IsZero(m.Comment) { // not required
		return nil
	}

	if m.Comment != nil {

		if err := m.Comment.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("comment")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateCompatibleAgents(formats strfmt.Registry) error {

	if swag.IsZero(m.CompatibleAgents) { // not required
		return nil
	}

	if m.CompatibleAgents != nil {

		if err := m.CompatibleAgents.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("compatibleAgents")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateCustomArtifactDependencies(formats strfmt.Registry) error {

	if swag.IsZero(m.CustomArtifactDependencies) { // not required
		return nil
	}

	if m.CustomArtifactDependencies != nil {

		if err := m.CustomArtifactDependencies.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("custom-artifact-dependencies")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateLastChanges(formats strfmt.Registry) error {

	if swag.IsZero(m.LastChanges) { // not required
		return nil
	}

	if m.LastChanges != nil {

		if err := m.LastChanges.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("lastChanges")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateLinks(formats strfmt.Registry) error {

	if swag.IsZero(m.Links) { // not required
		return nil
	}

	if m.Links != nil {

		if err := m.Links.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("links")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateMetadata(formats strfmt.Registry) error {

	if swag.IsZero(m.Metadata) { // not required
		return nil
	}

	if m.Metadata != nil {

		if err := m.Metadata.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("metadata")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validatePinInfo(formats strfmt.Registry) error {

	if swag.IsZero(m.PinInfo) { // not required
		return nil
	}

	if m.PinInfo != nil {

		if err := m.PinInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("pinInfo")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateProblemOccurrences(formats strfmt.Registry) error {

	if swag.IsZero(m.ProblemOccurrences) { // not required
		return nil
	}

	if m.ProblemOccurrences != nil {

		if err := m.ProblemOccurrences.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("problemOccurrences")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateProperties(formats strfmt.Registry) error {

	if swag.IsZero(m.Properties) { // not required
		return nil
	}

	if m.Properties != nil {

		if err := m.Properties.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("properties")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateRelated(formats strfmt.Registry) error {

	if swag.IsZero(m.Related) { // not required
		return nil
	}

	if m.Related != nil {

		if err := m.Related.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("related")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateRelatedIssues(formats strfmt.Registry) error {

	if swag.IsZero(m.RelatedIssues) { // not required
		return nil
	}

	if m.RelatedIssues != nil {

		if err := m.RelatedIssues.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("relatedIssues")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateReplacementIds(formats strfmt.Registry) error {

	if swag.IsZero(m.ReplacementIds) { // not required
		return nil
	}

	if m.ReplacementIds != nil {

		if err := m.ReplacementIds.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("replacementIds")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateResultingProperties(formats strfmt.Registry) error {

	if swag.IsZero(m.ResultingProperties) { // not required
		return nil
	}

	if m.ResultingProperties != nil {

		if err := m.ResultingProperties.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("resultingProperties")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateRevisions(formats strfmt.Registry) error {

	if swag.IsZero(m.Revisions) { // not required
		return nil
	}

	if m.Revisions != nil {

		if err := m.Revisions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("revisions")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateRunningInfo(formats strfmt.Registry) error {

	if swag.IsZero(m.RunningInfo) { // not required
		return nil
	}

	if m.RunningInfo != nil {

		if err := m.RunningInfo.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("running-info")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateSnapshotDependencies(formats strfmt.Registry) error {

	if swag.IsZero(m.SnapshotDependencies) { // not required
		return nil
	}

	if m.SnapshotDependencies != nil {

		if err := m.SnapshotDependencies.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("snapshot-dependencies")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateStatistics(formats strfmt.Registry) error {

	if swag.IsZero(m.Statistics) { // not required
		return nil
	}

	if m.Statistics != nil {

		if err := m.Statistics.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("statistics")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateTags(formats strfmt.Registry) error {

	if swag.IsZero(m.Tags) { // not required
		return nil
	}

	if m.Tags != nil {

		if err := m.Tags.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("tags")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateTriggered(formats strfmt.Registry) error {

	if swag.IsZero(m.Triggered) { // not required
		return nil
	}

	if m.Triggered != nil {

		if err := m.Triggered.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("triggered")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateTriggeringOptions(formats strfmt.Registry) error {

	if swag.IsZero(m.TriggeringOptions) { // not required
		return nil
	}

	if m.TriggeringOptions != nil {

		if err := m.TriggeringOptions.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("triggeringOptions")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateUser(formats strfmt.Registry) error {

	if swag.IsZero(m.User) { // not required
		return nil
	}

	if m.User != nil {

		if err := m.User.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("user")
			}
			return err
		}
	}

	return nil
}

func (m *Build) validateVersionedSettingsRevision(formats strfmt.Registry) error {

	if swag.IsZero(m.VersionedSettingsRevision) { // not required
		return nil
	}

	if m.VersionedSettingsRevision != nil {

		if err := m.VersionedSettingsRevision.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("versionedSettingsRevision")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Build) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Build) UnmarshalBinary(b []byte) error {
	var res Build
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
